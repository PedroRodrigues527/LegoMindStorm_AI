#pragma config(Sensor, S1,     Colour,         sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     Touch,          sensorEV3_Touch, modeEV3Bump)
#pragma config(Motor,  motorA,          toque,         tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          wheels,        tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorD,          grua,          tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
CONSTANTES DAS TABELAS DE VALORES DOS INIMIGOS
*/
#define T_MAX_FORCA 200
#define T_MAX_ATAQUES 2
#define T_MAX_VIDA 200

#define A_MAX_FORCA 500
#define A_MAX_ATAQUES 1
#define A_MAX_VIDA 50

#define I_MAX_FORCA 100
#define I_MAX_ATAQUES 3
#define I_MAX_VIDA 100

/*
CONSTANTES DA TABELA DE VALORES DO DEFENDER-BOT
*/
#define DB_MAX_VIDA 750
#define DB_MAX_EN 500

#define DB_ATAQUE_GRUA 200
#define DB_CONSUMO_GRUA 300
#define DB_ATAQUE_TOQUE 100
#define DB_CONSUMO_TOQUE 150
#define DB_ATAQUE_SOM 50
#define DB_CONSUMO_SOM 50

#define DB_VIDA_CURA1 100
#define DB_CONSUMO_CURA1 200
#define DB_VIDA_CURA2 200
#define DB_CONSUMO_CURA2 300
#define DB_VIDA_CURA3 400
#define DB_CONSUMO_CURA3 400


//*****************************************INICIALIZAÇÃO

//array de inimigos
int tanque[3] = {T_MAX_FORCA,T_MAX_ATAQUES,T_MAX_VIDA};
int artilharia[3] = {A_MAX_FORCA,A_MAX_ATAQUES,A_MAX_VIDA};
int infantaria[3] = {I_MAX_FORCA,I_MAX_ATAQUES,I_MAX_VIDA};
int arrayenemies[6][3] = {{NULL,NULL,NULL},{NULL,NULL,NULL},{NULL,NULL,NULL},{NULL,NULL,NULL},{NULL,NULL,NULL},{NULL,NULL,NULL}};
//array de defender-bot
int db_ataques[3][2] = {{DB_ATAQUE_GRUA,DB_CONSUMO_GRUA},{DB_ATAQUE_TOQUE,DB_CONSUMO_TOQUE},{DB_ATAQUE_SOM,DB_CONSUMO_SOM}};
int db_curas[3][2] = {{DB_VIDA_CURA1,DB_CONSUMO_CURA1},{DB_VIDA_CURA2,DB_CONSUMO_CURA2},{DB_VIDA_CURA3,DB_CONSUMO_CURA3}};
int db[2] = {DB_MAX_VIDA,DB_MAX_EN};


//*****************************************FUNCOES AUXILIARES

//movimento - movimentar para frente ou atrás.
void movimento(int pos)
{
	setMotorTarget(wheels, -620*(pos+1), 35); //movimenta as rodas em 620 distância vezes a posição do array + 1 para frente com velocidade a 35%
	waitUntilMotorStop(wheels); //o programa espera até que wheels chegue ao destino
	sleep(200); //0.2 segundos
}

//ataqueDB - ação dos tipos de ataque DB
void ataqueDB(int pos, int tipo)
{
	int enantes = db[1]; //guarda energia de db antes de alterar
	db[1] -= db_ataques[tipo][1]; //retira energia
	int vidainimantes = arrayenemies[pos][2]; //guarda vida de inimigo antes de alterar
	arrayenemies[pos][2] -= db_ataques[tipo][0]; //inimigo perde vida

	//mostrar atributos de db atuais
	displayCenteredTextLine(7,"%s %d %s %d", "Energia:", enantes, "->", db[1]); //Energia: 500 -> 450
	displayCenteredTextLine(9,"%s %d %s %d", "Vida inimigo:", vidainimantes, "->", arrayenemies[pos][2]); //Vida inimigo: 50 -> 0

	switch(tipo) //tipo de ataque
	{
	case 0:
		//ATAQUEGRUA
		//motor de grua
		playSoundFile("Boing"); //ficheiro de som "Boing"
		setMotorTarget(grua,380,30); //desce a grua
		waitUntilMotorStop(grua); //esperar por grua
		sleep(1000); //1 segundo
		setMotorTarget(grua,0,15); //sobe a grua
		waitUntilMotorStop(grua); //esperar por grua
		sleep(1000); //1 segundo
		break;
	case 1:
		//ATAQUETOQUE
		playSoundFile("Touch"); //ficheiro de som "Touch"
		setMotorTarget(toque,100,30); //desce a garra
		waitUntilMotorStop(toque); //esperar que o motor de toque pare
		sleep(1000); //1 segundo
		setMotorTarget(toque,0,15); //sobe a garra
		waitUntilMotorStop(toque); //esperar que o motor de toque pare
		sleep(1000); //1 segundo
		break;
	case 2:
		//ATAQUESOM
		playSoundFile("Sonar"); //ficheiro de som "Sonar"
		break;
	default:
		//UNKNOWN
	}

	sleep(3000); //3 segundos
	displayCenteredTextLine(7,"%s %d", "Energia:", db[1]); //Energia: 450
	displayCenteredTextLine(9,""); //
	sleep(1000); //1 segundo
}

//curaDB - ação dos tipos de cura DB
void curaDB(int tipo)
{
	int antesvida = db[0]; //guardar vida DB antes de alterar
	db[0] += db_curas[tipo][0]; //regenera vida DB
	int antesener = db[1]; //guardar energia DB antes de alterar
	db[1] -= db_curas[tipo][1]; //retira energia DB

	//mostrar atributos de db atuais
	displayCenteredTextLine(7,"%s %d %s %d", "Energia:", antesener, "->", db[1]); //Energia: 500 -> 200
	displayCenteredTextLine(6,"%s %d %s %d", "Vida:", antesvida, "->", db[0]); //Vida: 250 -> 450

	playSoundFile("Magic wand"); //ficheiro de som "Magic wand"
	sleep(1000); //1 segundo
	switch(tipo) //tipo de cura
	{
	case 0:
		//CURA1
		playSoundFile("Zero"); //ficheiro de som "Zero" - só para distinguir a cura 1 de outras curas
		break;
	case 1:
		//CURA2
		playSoundFile("Four"); //ficheiro de som "Four" - só para distinguir a cura 2 de outras curas
		break;
	case 2:
		//CURA3
		playSoundFile("Three"); //ficheiro de som "Three"
		break;
	default:
		//UNKNOWN
	}

	sleep(3000); //3 segundos
	displayCenteredTextLine(7,"%s %d", "Energia:", db[1]); //Energia: 200
	displayCenteredTextLine(6,"%s %d", "Vida:", db[0]); //Vida: 450
	sleep(1000); //1 segundo
}

//inserirInimigo - quando o inimigo é inserido no slot pela primeira vez
void inserirInimigo(int pos, string str, int forca)
{
	displayCenteredBigTextLine(4, "%s %s", str, "INSERIDO!"); //ART INSERIDO!
	arrayenemies[pos][0] = forca; //{{500,NULL,NULL},...}, isto acontece para poder fazer o switch
	for(int j = 1; j < 3; j++)
	{
		switch(arrayenemies[pos][0]) //verificar a força máxima de um inimigo presente no slot
		{
		case 500: //artilharia
			arrayenemies[pos][j] = artilharia[j]; //{{500,1,50},...}
			break;
		case 200: //tanque
			arrayenemies[pos][j] = tanque[j];
			break;
		case 100: //infantaria
			arrayenemies[pos][j] = infantaria[j];
			break;
		default:
			break;
		}
	}
	displayCenteredTextLine(6,"%s %d", "Forca:", arrayenemies[pos][0]); //Forca: 500
	displayCenteredTextLine(7,"%s %d", "Ataques restantes:", arrayenemies[pos][1]); //Ataques restantes: 1
	displayCenteredTextLine(8,"%s %d", "Vida:", arrayenemies[pos][2]); //Vida: 50

	displayCenteredTextLine(12, "%s %d", "Vida de DB:", db[0]); //Vida de DB: 750

	playSoundFile("Ready"); //ficheiro de som "Ready"
}

//ataqueInimigo - quando existir inimigo no slot, este pode atacar ou não, dependendo das suas condições de vida e numero de ataques
void ataqueInimigo(int pos, string str)
{
	//SE TEM AS CONDIÇÕES PARA ATAQUE - num_ataques > 0 e vida > 0
	if(arrayenemies[pos][1] > 0 && arrayenemies[pos][2] > 0)
	{
		displayCenteredBigTextLine(4, "%s %s", str, "ATACOU!"); //ART ATACOU!

		//inimigo calcula valor para atacar DB
		float percentvida;
		switch(arrayenemies[pos][0])
		{
		case 500:
			percentvida = ((float)arrayenemies[pos][2] / A_MAX_VIDA);
			break;
		case 200:
			percentvida = ((float)arrayenemies[pos][2] / T_MAX_VIDA);
			break;
		case 100:
			percentvida = ((float)arrayenemies[pos][2] / I_MAX_VIDA);
			break;
		default:
			percentvida = 0.0;
			break;
		}

		//mostrar vida de db ANTES DO ATAQUE
		int vidaantes = db[0];

		//ATAQUE
		db[0] = (int) (db[0] - ( arrayenemies[pos][0] * (float)percentvida ));

		//mostrar vida de db DEPOIS DO ATAQUE
		displayCenteredTextLine(12, "%s %d %s %d", "Vida de DB:", vidaantes, "->", db[0]); //Vida de DB: 750 -> 250

		playSoundFile("Ouch"); //ficheiro de som "Ouch"

		//decrementa num_ataque
		arrayenemies[pos][1] -= 1;

		//mostrar atributos de inimigo
		displayCenteredTextLine(6,"%s %d", "Forca:", arrayenemies[pos][0]); //Forca: 500
		displayCenteredTextLine(7,"%s %d", "Ataques restantes:", arrayenemies[pos][1]); //Ataques restantes: 0
		displayCenteredTextLine(8,"%s %d", "Vida:", arrayenemies[pos][2]); //Vida: 50
	}
	//SENÃO, INDICA QUE JÁ NÃO ATACA (ou morreu ou num_ataques = 0)
	else
	{
		displayCenteredBigTextLine(4, "%s %s", str, "NAO ATACOU!"); //ART NAO ATACOU!
		//mostrar atributos de inimigo
		displayCenteredTextLine(6,"%s %d", "Forca:", arrayenemies[pos][0]); //Forca: 500
		displayCenteredTextLine(7,"%s %d", "Ataques restantes:", arrayenemies[pos][1]); //Ataques restantes: 1
		displayCenteredTextLine(8,"%s %d", "Vida:", arrayenemies[pos][2]); //Vida: 0

		displayCenteredTextLine(12, "%s %d", "Vida de DB:", db[0]); //Vida de DB: 750

		playSoundFile("No"); //ficheiro de som "No"
	}
}

//turnoInimigo - turno da força atacante
void turnoInimigo()
{
	//esperar até que seja pressionado botão de sensor de toque de EV3
	while(getBumpedValue(Touch) == 0) {}

	sleep(2000); //esperar 2 segundos
	resetBumpedValue(Touch); //bumpedTouch = 0;

	for(int i = 0; i < 6; i++) //vai de slot a slot
	{
		//MOTOR - RODAS PARA FRENTE
		movimento(i);

		if(arrayenemies[i][0] == NULL) //se o slot estiver vazio
		{
			//SENSOR - COR
			short currentColour;
			currentColour = SensorValue[Colour];
			displayCenteredBigTextLine(2, "%s %d", "SLOT", i+1);
			switch(currentColour)
			{
				// se for branca - slot vazio
			case 6:
				displayCenteredBigTextLine(4, "VAZIO");
				displayCenteredTextLine(6,"");
				displayCenteredTextLine(7,"");
				displayCenteredTextLine(8,"");
				displayCenteredTextLine(12, "%s %d", "Vida de DB:", db[0]);
				playSoundFile("White"); //ficheiro de som "White"
				// nada adicionado nem removido
				break;

				// se for azul - infantaria
			case 2:
				playSoundFile("Blue");
				sleep(2000);
				string nameenemy_i;
				nameenemy_i = "INF";
				inserirInimigo(i, nameenemy_i, infantaria[0]);
				break;

				// se for verde - tanque
			case 3:
				playSoundFile("Green"); //ficheiro de som "Green"
				sleep(2000);
				string nameenemy_t;
				nameenemy_t = "TANK";
				inserirInimigo(i, nameenemy_t, tanque[0]);
				break;

				// se for vermelho - artilharia
			case 5:
				playSoundFile("Yellow"); //vai dizer yellow mas vai reconhecer vermelho, porque o ficheiro de som "Red.rsf" não funciona
				sleep(2000);
				string nameenemy_a;
				nameenemy_a = "ART";
				inserirInimigo(i, nameenemy_a, artilharia[0]);
				break;

				// se for outra cor - nada/ignorar
			default:
				playSoundFile("Color"); //ficheiro de som "Color"
				displayCenteredBigTextLine(4, "DESCONHECIDO");
				displayCenteredTextLine(6,"");
				displayCenteredTextLine(7,"");
				displayCenteredTextLine(8,"");
				displayCenteredTextLine(12, "%s %d", "Vida de DB:", db[0]);
			}
		}
		else //se estiver um inimigo no slot
		{
			switch(arrayenemies[i][0]) //se é artilharia, tanque ou infantaria
			{
				case 500:
					//é artilharia
					playSoundFile("Yellow"); //vai dizer yellow mas vai reconhecer vermelho, porque o ficheiro de som "Red.rsf" não funciona
					sleep(2000);
					string nameenemy_a;
					nameenemy_a = "ART";
					ataqueInimigo(i, nameenemy_a);
					break;
				case 200:
					//é tanque
					playSoundFile("Green"); //ficheiro de som "Green"
					sleep(2000);
					string nameenemy_t;
					nameenemy_t = "TANK";
					ataqueInimigo(i, nameenemy_t);
					break;
				case 100:
					//é infantaria
					playSoundFile("Blue"); //ficheiro de som "Blue"
					sleep(2000);
					string nameenemy_i;
					nameenemy_i = "INF";
					ataqueInimigo(i, nameenemy_i);
					break;
				default:
					break;
			}
		}
		sleep(4000); //4 segundos
		eraseDisplay(); //apaga tudo o que está escrito no display
		if(db[0] <= 0) //se a vida de DB for menor ou igual a 0 (isto é, se já não tem vida)
		{
			break; //sai do ciclo for para rapidamente ir à função de derrota
		}
	}
	eraseDisplay(); //apaga tudo o que está escrito no display
	//MOTOR - RODAS PARA ATRÁS - IR AO INICIO
	movimento(-1);
}

//turnoDB - turno do defender-bot
void turnoDB()
{
	//ADICIONAR ENERGIA RECUPERADA
	int enantes = db[1]; //energia antes da recuperação

	float floatrecuperada = (float) db[1] * 0.5; //valor em float de recuperação de energia
	int intrec = (int) floatrecuperada; //valor em int de recuperação de energia
	if(db[1] + intrec > 500) //se energia antes + energia de recuperação em int exceder o máximo de energia possível
	{
		intrec = 500 - db[1]; //energia recuperação vai ter o valor restante para 500 de energia
		db[1] = 500; //energia de DB vai ser o máximo - 500
	}
	else
	{
		db[1] += intrec; //somar a energia antes com a energia de recuperação
	}

	displayCenteredBigTextLine(4, "DEFENDER-BOT");
	//mostrar atributos de db atuais
	displayCenteredTextLine(6,"%s %d", "Vida:", db[0]);
	displayCenteredTextLine(7,"%s %d %s %d %s %d", "Energia:", enantes, "+", intrec, "=", db[1]);
	sleep(5000); //5 segundos
	playSound(soundBlip); //Som predefinido do ev3
	displayCenteredTextLine(7,"%s %d", "Energia:", db[1]);
	sleep(3000); //3 segundos

	//primeiro vai atacar inimigo(s) que estejam vivos se possível

	//verificar artilharias
	for(int i = 0; i < 6; i++)
	{
		if(arrayenemies[i][0] == 500)
		{
			//é artilharia - é o mais prioritário, porque esta ou ataca a 100% ou não ataca
			//se energia de db >= 150, num_ataque > 0, artilharia está a 50 unidades de vida e ainda não foi atacado por DB
			if(db[1] >= 150 && arrayenemies[i][1] > 0 && arrayenemies[i][2] > 0)
			{
				//MOTOR - RODAS PARA FRENTE
				movimento(i);
				sleep(1000); //1 segundo
				//atacar
				//com ataque de som
				ataqueDB(i,2);
			}
		}
	}
	//verificar tanques
	for(int i = 0; i < 6; i++)
	{
		if(arrayenemies[i][0] == 200)
		{
			//é tanque
			//se energia de db >= 150, num_ataque > 0, artilharia está a 50 unidades de vida e ainda não foi atacado por DB
			if(db[1]>=450 && arrayenemies[i][1] > 0 && arrayenemies[i][2] == 200)
			{
				//MOTOR - RODAS PARA FRENTE
				movimento(i);
				sleep(1000); //1 segundo
				//atacar
				//com ataque de grua
				ataqueDB(i,0);
			}
			else if(db[1]>=350 && arrayenemies[i][1] > 0 && arrayenemies[i][2] >= 100)
			{
				//MOTOR - RODAS PARA FRENTE
				movimento(i);
				sleep(1000); //1 segundo
				//atacar
				//com ataque de toque
				ataqueDB(i,1);
			}
			else if(db[1] >= 250 && arrayenemies[i][1] > 0 && arrayenemies[i][2] >= 50)
			{
				//MOTOR - RODAS PARA FRENTE
				movimento(i);
				sleep(1000); //1 segundo
				//atacar
				//com ataque de som
				ataqueDB(i,2);
			}
		}
	}
	//verificar infantaria
	for(int i = 0; i < 6; i++)
	{
		if(arrayenemies[i][0] == 100)
		{
			//é infantaria
			if(db[1]>=300 && arrayenemies[i][1] > 0 && arrayenemies[i][2] >= 100)
			{
				//MOTOR - RODAS PARA FRENTE
				movimento(i);
				sleep(1000); //1 segundo
				//atacar
				//com ataque de toque
				ataqueDB(i,1);
			}
			else if(db[1] >= 200 && arrayenemies[i][1] > 0 && arrayenemies[i][2] >= 50)
			{
				//MOTOR - RODAS PARA FRENTE
				movimento(i);
				sleep(1000); //1 segundo
				//atacar
				//com ataque de som
				ataqueDB(i,2);
			}
		}
	}

	//CURAS
	//se vida < 750
	if(db[0] < 750)
	{
		//se vida <= 650 e energia >= 400 -> usar a cura 1
		if(db[0] <= 650 && db[1] >= 400)
		{
			curaDB(0);
		}
		//se vida <= 550 e energia >= 450 -> usar a cura 2
		else if(db[0] <= 550 && db[1] >= 450)
		{
			curaDB(1);
		}
		//se vida <= 350 e energia >= 500 -> usar a cura 3
		else if(db[0] <= 350 && db[1] >= 500)
		{
			curaDB(2);
		}
	}
	sleep(1000); //1 segundo
	eraseDisplay(); //apagar o display inteiro
	//MOTOR - RODAS PARA ATRÁS - IR AO INICIO
	movimento(-1);
}

//*****************************************FUNCAO MAIN

task main()
{
	/*
	IMPLEMENTAÇÃO
	*/
	setSoundVolume(65); //o volume dos sons vai estar a 65%
	eraseDisplay(); //apagar todo o display de EV3

	playSoundFile("Start up");
	sleep(1000); //1 segundo

	//contagem de turnos restantes
	for(int turnosrestantes = 13; turnosrestantes > 0; turnosrestantes--)
	{
		//se não tem vida restante -> derrota
		if(db[0] <= 0)
		{
			//sai do ciclo de turnos para ir diretamente à verificação de vida de DB
			break;
		}

		//mostrar ronda
		displayCenteredBigTextLine(4, "%s %d", "Ronda", 13-(turnosrestantes-1));
		sleep(2000); //2 segundos

		//se turnorestantes for par, signifíca que pertence à sequência 2,4,6,8,10,12 -> turno DB
		if(turnosrestantes % 2 == 0)
		{
			displayCenteredBigTextLine(8, "DEFENDER-BOT");
			playSoundFile("Hello");
			sleep(3000); //3 segundos
			eraseDisplay(); //apagar todo o display de EV3
			sleep(200); //0.2 segundos
			turnoDB();
		}
		//se turnosrestantes for ímpar, significa que pertence à sequência 1,3,5,7,9,11,13 -> turnoInimigo
		else
		{
			displayCenteredBigTextLine(8, "FORCA ATACANTE");
			playSoundFile("Uh-oh");
			sleep(3000); //3 segundos
			eraseDisplay(); //apagar todo o display de EV3
			sleep(200); //0.2 segundos
			turnoInimigo();
		}
	}

	//se ainda tiver vida restante no fim do jogo -> vitoria
	if(db[0] > 0)
	{
		eraseDisplay(); //apagar todo o display de EV3
		displayCenteredBigTextLine(8, "** VITORIA **");

		//adicionar som de vitoria
		playSoundFile("Good job"); //ficheiro de som "Good job"
	}
	//se não tem vida restante -> derrota
	else
	{
		eraseDisplay(); //apagar todo o display de EV3
		displayCenteredBigTextLine(8, "** DERROTA **");

		//adicionar som de derrota
		playSoundFile("Game over"); //ficheiro de som "Game Over"
	}

	sleep(7000); //7 segundos
	eraseDisplay(); //apagar todo o display de EV3
	playSoundFile("Goodbye"); //ficheiro de som "Goodbye"
	sleep(2000); //2 segundos
}
